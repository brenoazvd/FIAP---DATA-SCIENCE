# -*- coding: utf-8 -*-
"""Revisão de classes e orientação de objetos Aula 6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LCf96NlHjqudnjRFlWmXs7zGNQne_aGe
"""

class Animal(): #classe mãe
  def __init__(self, color, name):
    self.nome = name
    self.cor = color
    self.respirar()

  def respirar(self):
    print("respirando...")

class Gato(Animal):
  def __init__(self, color, name, qtd_garras):
    super().__init__(color, name) #chamando o construtor da classe mãe
    self.garras = qtd_garras #atributo especializado da classe filha

  def miar(self): #método especializado da class "gato"
    print("Miau")

class Burro(Animal):
  def __init__(self, color, name, qtd_cascos):
    super().__init__(color, name)
    self.cascos = qtd_cascos

  def relinchar(self):
    print("Inhóó inhóó")

gatinho = Gato('Tom', 'cinza', 2)

gatinho.miar()

gatinho.cor #atributo não pôe "()"" | atributo é uma caracteristica.

gatinho.respirar() #metodo põe () | metodo é ação.

burrinho = Burro("verde", "Jeca", 4)
print(burrinho.cor)
print(burrinho.nome)
print(burrinho.cascos)
burrinho.respirar()
burrinho.relinchar()



"""Um banco possui dois tipos de
cliente: Pessoa Física e Pessoa
Jurídica. Ambos os clientes possuem endereço, telefone, email, número da conta corrente e agência.
Todo PJ tem também razão social e cnpj, já PF tem nome e cpf, Os clientes pode sacar dinheiro  e visualizar saldo.
Construa as classes com seus respectivos métodos e atributos e instancie ao menos 1 objeto de cada classe (PF e Pj)
"""

class Cliente():
  def __init__(self, endereco, tel, email, n_conta_corrente, n_conta_agencia, senha):
    self.endereco = endereco
    self.tel = tel
    self.email = email
    self.n_conta_corrente = n_conta_corrente
    self.n_conta_agencia = n_conta_agencia
    self.__senha = senha
    self.__money = 0 #não é necessário deixar na função (init)

#Correção do professor
  def depositar(self, money):
    if money > 0:
      self.__money += money
      print(f"Déposito de R${money} efetuado com sucesso!")
    else:
      print("Não é possível depositar esse valor.")

  def ver_money(self, senha):
    if senha == self.__senha:
      return self.__money
    else:
      print("Senha inválida!")
      return None

  def sacar(self, senha, money):
    if senha == self.__senha:
      if money > 0:
        if money <= self.__money:
          self.__money -= money
          print("Saque efetuado com sucesso!")
          print("Saldo R$", self.ver_money(senha))
        else:
          print("O valor solicitado é superior ao seu saldo")
      else:
        print("Não é possível sacar este valor")
    else:
      print("Senha incorreta!")

class PJ(Cliente): #PJ herda de cliente
  def __init__ (self, endereco, tel, email, n_conta_corrente, n_conta_agencia, senha, razao_social, cnpj):
    super().__init__(endereco, tel, email, n_conta_corrente, n_conta_agencia, senha)
    self.ro_sl = razao_social
    self.cnpj = cnpj

class PF(Cliente): #PF herda de cliente
  def __init__ (self, endereco, tel, email, n_conta_corrente, n_conta_agencia,senha ,name, cpf):
    super().__init__(endereco, tel, email, n_conta_corrente, n_conta_agencia, senha)
    self.name = name
    self.cpf = cpf

PJ1 = PJ( "av. dr. 213", 1998323123, "brenrar@gmadua.xom", 313123, 2313132, "senha1", "MBE", 123123123123 )

PF1 = PF("av. re. g 333", 11987654352, "brenaora@gmasd.com", 312321314, 32313123, "senha2", "Breno Rodrigues Azevedo", 43232134123)

PJ1.ro_sl

PJ1.depositar(10)

PJ1.depositar(1000)

PJ1.sacar("senha1", 100)

PJ1.ver_money("457")





import pandas as pd

#dataframe(df)

dados = {
    'clientes': ['João', ' Maria', 'José'], #Dados categoricos clientes e sexo
    'idade': [22, 34, 68],
    'mensalidade': [1700.0, 2500.0, 1500.0], #Numerica continua nota, mensalidade e qtd_comprada
    'qtd_comprada': [50, 60 ,70],
    'sexo': ['M', 'F', 'M']
}
dados #lista

df = pd.DataFrame(dados)
df

df.tail(2)

df['clientes'] #atributo

df.idade #atributo

import numpy as np
dadinhos = [10, 20, 30, 40, 50, 60]

print(np.max(dadinhos))
print(np.min(dadinhos))

def normalizar(x):
  return (x - np.min(x))/(np.max(x) - np.min(x)) #x será uma lista de valores númericos

def padronizar(x):
    return (x -np.mean(x))/np.std(x)

print(dadinhos)
print(normalizar(dadinhos))

padronizar(df['idade'])

normalizar(df['mensalidade'])

normalizar(df['idade'])

def shapiro(dados):
  from scipy import stats
  stat, p_valor = stats.shapiro(dados)
  print('estatística de teste de Shapiro-Wilk:', stat)
  print('Valor p:', p_valor)
  alpha = 0.20
  if p_valor > alpha:
    print('Os dados parecem seguir uma distribuição normal')
    return 1
  else:
    print('Os dados não seguem uma distribuição normal')
    return 0

for coluna in ['qtd_comprada', 'mensalidade', 'idade']:
  print(coluna)
  n = shapiro(df[coluna])
  if n == 1:#se a coluna é gassiana(distrib. normal)
    df[coluna] = padronizar(df[coluna])
  else: #senão, se a coluna não é gaussiana
    df[coluna] = normalizar(df[coluna])
  print('______________')
df

#'''df['qtd_comprada'] = padronizar(df['qtd_comprada'])
#df['idade'] = padronizar(df['idade'])
#df['mensalidade'] = normalizar(df['mensalidade'])

dados

#df = df.drop('clientes', axis=1)#axis eixos (vertical) 1= coluna (horizontal) 0= linha
#df.drop('clientes', axis=1, inplace=True)
df = df.drop(columns=['clientes']) #dropa todas as colunas que escrever de uma vez
df

df.info()

df.isna().sum() #Soma todos os NaN's de cada coluna | NaN = sem número

df.dropna()#Dropa todas as linhas que tenham ao menos um NaN
df

df = pd.get_dummies(df, columns=['sexo']) #Separa a coluna categorica em duas colunas com 0 e 1.
df

df_titanic = pd.read_csv('/home/train.csv')
df_titanic

df_titanic = df_titanic.drop(columns=['id', 'nome', 'bilhete'])
df_titanic

df_titanic.isna().sum()

df_titanic = df_titanic.dropna()
df_titanic.isna().sum