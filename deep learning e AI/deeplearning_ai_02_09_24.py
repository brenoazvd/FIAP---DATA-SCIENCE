# -*- coding: utf-8 -*-
"""DeepLearning_ai_02_09_24.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_KPBgWNDQAuH0MozxquyrpTkaLhlU55Q

Classificador de Dígitos MNIST com Redes Neurais Convolucionais

Breno Azevedo

##Rede Neural Convulsional
"""

import matplotlib.pyplot as plt
from keras.datasets import mnist
from keras.models import Sequential
from keras.layers import Dense, Flatten
import keras.utils as utils
from keras.layers import Conv2D, MaxPooling2D
import numpy as np

(X_treinamento, y_treinamento), (X_teste, y_teste) = mnist.load_data()

plt.imshow(X_treinamento[9])
#plt.imshow(X_treinamento[9], cmap='gray') - Para deixar em preto em branco, ajuda no processamento
plt.title('Classe = ' + str (y_treinamento[9]))

previsores_treinamento = X_treinamento.reshape(X_treinamento.shape[0],
                                               28,28, #altura x largura das imagens
                                               1 #quantidade de canais (RBG = 3, preto e branco = 1)
                                               )

previsores_teste = X_teste.reshape(X_teste.shape[0], 28,28, 1)

previsores_treinamento = previsores_treinamento.astype('float32')
previsores_teste = previsores_teste.astype('float32')
#Como os dados são do tipo unit8 (tipo do pixel), será necessário converter para float32,
#pois posteriormente vamos aplicar uma normalização
#que poderá conter números de casas decimais.

previsores_teste /= 255
previsores_treinamento /= 255

#Parâmetros do método to_categorical: número de registros e número de classes
classe_treinamento = utils.to_categorical(y_treinamento, 10)
classe_teste = utils.to_categorical(y_teste, 10)

classificador = Sequential ()
classificador.add(Conv2D(32,
                         (3,3),# Recomendado 64 filtros
                         input_shape=(28,28,1),
                         activation='relu')
                  )

classificador.add(MaxPooling2D(pool_size=(2,2)))

classificador.add(Flatten())

#para criar as redes neurais use a base binária para definir os neurônios 2 4 8 16 32 64 128 256...

#1ª camada oculta
classificador.add(Dense(units=128, activation='relu'))

#camada de saída
classificador.add(Dense(units=10, activation='softmax'))

classificador.compile(
                        loss='categorical_crossentropy',
                        optimizer='adam', #padrão
                        metrics=['accuracy']
)

classificador.fit(previsores_treinamento, classe_treinamento,
                  batch_size=128, #tamanho do lote de treinamento(pacotes de treinamento de 128 em 128)
                  epochs=5,
                  validation_data=(previsores_teste, classe_teste)#assim que treina, já testa!
                  )

import tensorflow as tf
print (tf.__version__)

#Criando a própria imagem para efetuar a previsão
import cv2
import matplotlib.pyplot as plt
from tensorflow.keras.utils import img_to_array
#Carregandoa imagem do diretório do colab
file = '/home/MNIST_imagem_exemplo_1.jpg'
test_image = cv2.imread(file, cv2.IMREAD_GRAYSCALE)

#Visualizando  a imagem em preto e branco
#plt.imshow(test_image, cmap='gray')

#formatando a imagem para o formato do nosso treinamento
img_resized = cv2.resize(test_image, (28, 28), interpolation=cv2.INTER_LINEAR)
img_resized = cv2.bitwise_not(img_resized)

#visualizando a imagem após ser convertida
plt.imshow(img_resized, cmap='gray')

x = img_to_array(img_resized)
x = np.expand_dims(x, axis=0)
#efetuando previsão
previsao = classificador.predict(x)
print(previsao)

#Criando a própria imagem para efetuar a previsão
import cv2
import matplotlib.pyplot as plt
from tensorflow.keras.utils import img_to_array
#Carregandoa imagem do diretório do colab
file = '/home/imagem3.jpg'
test_image = cv2.imread(file, cv2.IMREAD_GRAYSCALE)

#Visualizando  a imagem em preto e branco
#plt.imshow(test_image, cmap='gray')

#formatando a imagem para o formato do nosso treinamento
img_resized = cv2.resize(test_image, (28, 28), interpolation=cv2.INTER_LINEAR)
img_resized = cv2.bitwise_not(img_resized)

#visualizando a imagem após ser convertida
plt.imshow(img_resized, cmap='gray')

x = img_to_array(img_resized)
x = np.expand_dims(x, axis=0)
#efetuando previsão
previsao = classificador.predict(x)
print(previsao)